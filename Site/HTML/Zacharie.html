<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Language" content="fr" />
        <title>TetrisSite - ISN2019</title>
        <link rel='stylesheet' type='text/css' href="..\STYLE\laFeuuille.css">
        <script defer src="https://use.fontawesome.com/releases/v5.8.1/js/all.js" integrity="sha384-g5uSoOSBd7KkhAMlnQILrecXvzst9TdC09/VM+pjDTCM+1il8RHz5fKANTFFb+gQ" crossorigin="anonymous"></script>
    </head>

    <body>
        <header id="header">
    	    <a href="TetrisSite.html" title="Home">
                <img src="../Img/tetris-logo.png" alt="Tetris" width="350px">
            </a>
        </header>
  
        <nav id="menu">
            <table width="100%" cellspacing="0" cellpadding="0" border="0">
                <tbody><tr>
                    <td>&nbsp;</td>
                    <td width="1" align="center"><a href="TetrisSite.html">Acceuil</a></td>
                    <td>&nbsp;</td>
                    <td width="1" align="center"><a href="Nidhal.html">Nidhal</a></td>
                    <td>&nbsp;</td>
                    <td width="1" align="center"><a href="Brice.html">Brice</a></td>
                    <td>&nbsp;</td>
                    <td width="1" align="center">Zacharie</td>
                    <td>&nbsp;</td> 
                    <td width="1" align="center"><a href="http://localhost/TravailWIP/PHP.php">PHP</a></td>
                    <td>&nbsp;</td>
                    <!-- icon GitHub (en dessous) -->
                    <td width="1" align="center"><a target="_blank" href="https://github.com/Jediiah/Tetris-ISN-2019"><span style="font-size: 2em; color: purple;"><i class="fab fa-github"></i></span></a></td>
                    <td>&nbsp;</td>
                   
                </tr></tbody>
            </table>  
        </nav>
 
 
    <span id="content">
    
        <div style="float:left; width:700px; margin-right:16px; margin-bottom:16px;"><span class="title">Le super dossier de Zacharie</span><br><br><br>
<br>
Vous voici sur la page où j'explique l'inextricable charabias que j'ai codé. Comme dis <a href="TetrisSite.html" >plus tôt</a> le fonctionnement général du jeu à été travaillé par Brice et moi. 
Ce qui s'est traduit par le module <span class="nomDeFichier">CLASSES</span>, que j'ai cependant entièrement écrit ainsi que la partie délimité par ==TETRIS== dans <span class="nomDeFichier">TetrisJeu</span>.
<br>
Avant de commencer je vous rappelle qu'il est conseillé de lire le dossier de <a href="Brice.html" >Brice</a> avant celui-ci.
<br>
<br>
<br>
&nbsp; J'expliquerais <span class="nomDeFichier">CLASSES</span> pour permettre de mieux comprendre la boucle du jeu dans <span id="classe_tablo" class="nomDeFichier">TestBis</span>.
<br>

<br>
<br>
<br>Le module <span class="nomDeFichier">CLASSES</span> contient les définitions des deux classes utilisées (de nouveaux objets).
<br>
&nbsp; &nbsp; &nbsp; La première classe est la classe <span class="code">tablo</span> qui contient le <a href="Brice.html#tableau">tableau</a>, le score et l'état du jeu  &nbsp;
(: <spoan class="code">isVide</spoan> indique s'il y a une pièce en mouvement dans le jeu et <span class="code">gameOver</span> si le joueur a perdu). Cette classe contient aussi deux fonctions:
<ul>
    <li>
        Premièrement la fonction <span id="fctn_tablo_test" class="code">test()</span> permet de détecter des lignes hoizontales complètes et de les supprimer.
        <br>
        Dans cette fonction une première boucle regarde les lignes du tableau une par une et si une ligne complète est détectée, la supprime et fait "descendre" celles au dessus.
        Une fois que toutes les lignes sont descendues (=quand une ligne vide est detectée ou quand on arrive en haut) la boucle recommence à la même ligne (le <span class="code">i -= 1</span>)
        ce qui permet de fonctionner lorsqu'il y a deux lignes pleines à la suite (c'est mieux quand même).
        <br>
        Finalement la variable <span class="code">combo</span> permet de détecter un "TETRIS" (4 lignes d'un coup) qui rapporte 800 points contre 100 pour une seule ligne.
    </li>
    <br>
    <li>
    Ensuite la fonction <span id="fctn_tablo_update" class="code">update()</span> qui actualise la position du bloc en mouvement.
    <br>
    Pour plus de clarté je vais éxpliquer chaque argument de cette fonction.
    <br>
    <br>
    <code><pre>def update(self, estArrive=False, formestr="",positionsAvant=[]
         , positionsApres=[]):</pre> </code>
    <br>
    <br>
    <ul>
        <li><span class="code">esrArrive</span> est un booléen, faux par défaut, qui indique lorsque la pièce en mouvement est arrivée et ne pourra plus bouger.</li>
        <li><span class="code">positionsAvant</span> et <span class="code">positionsApres</span> sont les <a href="Brice.html#pieces">positions</a> (listes de tuples)
        de la pièce avant et après le déplacement ou la rotation de celle-ci.</li>
        <li><span class="code">formestr</span> est la forme de la pièce pour insérer la bonne dans le <a href="Brice.html#pieces">tableau</a>.</li>
    </ul>
    <br>
    Voyons maintenant le fonctionement de la fonction <span style="font-size: 1em; color: #247069";><i class="far fa-smile"></i></span>.
    <ul>
        <li>Si la pièce est encore en trian de tomber (estArrive = False, valeur par défaut), les blocs constituant la pièce avant le déplacement sont supprimés du tablo
            (les cases correspondantes sont vidées). Ensuite les blocs constituant la pièce après le déplacement sonr "insérées" dans le tablo (la valeur de <span class="code">formestr</span> est donnée aux la case correspondantes).</li>
        <li>Si la pièce a fini de tomber, les positions sont actualisées de la même manière et l'état du tablo passe à vide (<span class="code">tablo.isvide = True</span>) 
            , ce qui permet d'indiquer qu'il faut créer une nouvelle pièce.</li>
    </ul>
    </li>
</ul>
<br>
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; La seconde classe est la classe <span id="classe_newBlock" class="code">newBlock</span> qui désigne la pièce en mouvement dans le tableau.
Contrairement à <span class="code">tablo</span>, celle-ci a besoin d'arguments qui servent à l'initialisation de la pièce.
<br>
<code id="fctn_newBlock_init"><pre>def __init__(self, laForme, positions_init, tablo):
        self.orient = 'DOWN'
        self.forme = laForme
        give_position(positions_init[self.orient], self.forme, tablo)
        self.positions = positions_init
        self.rotationCorompue = []</pre>
</code><br>
<ul>
    <li><span class="code">orient</span> est l'initialisation de <a href="Brice.html#rotation">l'orientation</a> de la pièce sur 'DOWN'.</li>
    <li><span class="code">laForme</span> la forme de la pièce créée (<a href="Brice.html#pieces">+</a>) enregistrée dans l'objet comme <span class="code">forme</span></li>
    <li><span class="code">positions_init</span> est la <a href="Brice.html#pieces">position</a> initiale de la pièce stockée dans <span class="code">CONST</span>
        Grâce à ce dictionaire de positions on initialise la position de la pièce dans le tablo : <span class="code">give_position()</span> (plus de détails <a href="#give_position">ici</a>)</li>
    <li><span class="code">tablo</span> est l'objet de la classe <span class="code">tablo</span> dans lequel se trouve la pièce crée.</li>
    <li><span class="code">rotationCorompue</span> est une liste des rotations qu'on ne peut plus utiliser.
        Parfois certaines rotations ont des carrés dont la position a une valeur négative ce qui les placent n'importe où. 
        Cette fonction a été développée en urgence pour éviter de telles horreurs (on verra comment après) mais la liste qu'elle génère devrait rester vide.</li>
</ul>
<br>
Cette classe possède aussi 2 fonctions:
<ul>
    <li>La première fonction est <span id="fctn_newBlock_deplacement" class="code">deplacement()</span> (c'est de ce charabia dont je parlais en introduction).
        Comme cette fonction me parrait complètement incompréhensible pour les autres mais que son intêret est évident, je propose de la réécrire ici en pseudo-language algorithmique.
        <code><pre>fonction déplacer(pièce, direction, tablo):
    peutDescendre = Vrai
    Si la direction est BAS:
        Pour (x,y) (x4), = la position de chaque carré de la pièce:
           Si y>0 ET, soit la case en dessous est occupée par un carré 
             -de la pièce soit cette case est vide:
                continuer = on teste avec le prochain carré
           Sinon Si la case dessous n'est pas un carré:
               peutDescendre = Faux 
               break = on arrete la boucle(ca sert à rien de continuer)
        
        Si peutDescendre est toujours vrai:
           positionAvant = sauvegarde de la position actuelle 
           Pour rotation i , = chaque rotation de la pièce
               Pour carré i de 0 à 4:
                   (x,y) = la position du carré i dans la rotaion i 
                   la position du carré i dans la rotaion i = (x,y-1)
               cleCorrmopue = test_rotation_corromp(rotation i)
               Si la rotaion i n'est pas déjà corrompue:
                   Si cleCorrompue est Vrai:
                       la rotaion i devient corrompue
               Sinon Si la rotation i est déjà corrompue:
                   Si cleCorrompue est Faux:
                       la rotation i est "décorrompue"
           tablo.update(formePièce, positionAvant, positionActuelle)
        Sinon:
           tablo.update(laPièceEstArrivée, formePièce, positionAvant)


    Sinon Si la direction est DROITE:
           # La même chose adaptée à la direction 
           # Cependant lorsque les tests échouent la pièce
           # n'est pas arrivée (Dernière ligne de DROITE)

    Sinon Si la direction est GAUCHE:
           # Comme DROITE  
        </pre></code>
        C'est donc une fonction de déplacement classique dans laquelle on actualise le tablo grâce à la fonction
        <a href="#fctn_tablo_update">tablo.update()</a> et on teste les éventuelles erreurs grâce à la fonction
        <a href="#test-rotation_corompt">test_rotation_coromp()</a> (détaillée plus bas).
    </li>
    <br>
    <li>
        La fonction suivante est la fonction de <span id="fctn_newBlock_rotation" class="code">rotation()</span> qui permet de faire "rotater" la pièce <span style="font-size: 1em; color: #247069";><i class="far fa-smile"></i></span>
        Cette fonction créé une liste de rotations possibles en fonction de la forme de la pièce. Cette liste permet de faire tourner la pièce toujours dans le même sens.
        La prochaine rotation choisie est la première dans le sens horaire si celle-ci n'est pas corrompue (ce qui n'arrive jamias évidemment).
        Une fois la prochaine rotation choisie on teste si les positions des carrés de la pièce dans cette rotation sont dans le tableau
        et qu'il ne sont pas sur un autre carré. Si on peut "rotater", les positions sont actualisées de la même manière que pour la fonction
        <span class="code">déplacement()</span> et si on ne peut pas, la rotation est annulée.
    </li>
</ul>
<br>
<br>
&nbsp; Finalement je vais présenter les trois fonctions restantes de ce module:
<ul id="autres_fonctions">
    <li id="give_position"><span class="code">give_position()</span> est la fonction qui permet d'incruster la piéce dans le tableau à sa création.
            Cette fonction permet aussi de détecter le gamOver : si la place initiale de la pièce est déjà occupée.</li>
    <li id="give_couleur"><span class="code">give_couleur()</span> permet de donner une couleur différente aux pièces en mouvement et aux pièces déjà tombées.
        Ce qui permet de mieux les distinguer lorsqu'on a besoin de chercher des erreurs dans le tableau.</li>
    <li id="test_rotation_coromp"><span class="code">test_rotation_coromp()</span></li>
</ul>
<br>
Voici donc pour ce module qui contient le "coeur" du jeu.
<br>
<br>
<br>
<br>
&nbsp; &nbsp; &nbsp; La suite est la boucle du jeu dans <span class="code">TetrisJeu</span> qui est délimitée par ("<span class="code">===TETRIS===</span>").
J'ai également codé cette partie qui utilise les classes et fonctions précédemment exlpliquées. 
<br>
Cette partie du programme arrive une fois que le <a href="Nidhal.html">menu</a> est passé. Avant de lancer la boucle
elle-même, nous avons besoin de "préparer le terrain". 
<br>
<br>
&nbsp; Tout d'abord nous affichons le fons du jeu pouvant être changé dans les options, ensuite nous avons besoin d'isoler certaines parties de la fenêtre (<span class="code">subspace()</span>) qui
aurons chacune une fonction spécifique.
<ul>
    <li><span class="code">platojeu</span> est la sous-fenêtre principale où est affiché le "jeu" ainsi qu'un cadrillage pour aider à visualiser.</li>
    <li><span class="code">afficheScore</span> est la sous fenêtre où le score est affiché.</li>
    <li><span class="code">visuPiece</span> est la sous fenêtre où la prochaine piece est affichée.</li>
</ul>
<br>
&nbsp; Ensuite un objet de la classe <span class="code">tablo</span> est créé: <span class="code">tabloJeu</span>. 
<br>
&nbsp; Puis on créé la descente automatique de la pièce : un nouvel événement <span class="code">gravite</span> et une commande 
qui produit cet événement toute les 500ms. Enfin notre moyen de choisir la prochaine pièce est de choisir une valeur aléatoire 
dans une liste.
<br>
<br>
&nbsp; &nbsp; A partir d'ici commence enfin la boucle du jeu qui est limitée à 15 boucles par seconde (<span class="code">clock.tick(15)</span>)
<br>
<ul>
    <li>D'abord si le <span class="code">tablo</span> est vide (<span class="code">tabloJeu.isVide==True</span>), on choisi la prochaine pièce qué l'on affiche dans 
<span class="code">visuPiece</span> puis on créer un objet de la classe <span class="code">newBlock</span> dans <span class="code">tabloJeu</span>.</li>
    <li>Ensuite on cherche tous les "inputs" détectés et on associe une fonction à ceux qu'on veut : flèches pour les directions (haut pour la rotation)
        et backspace pour quitter.</li>
    <li>Ensuite si le score à changer on actualise la fenêtre <span class="code">afficheScore</span>.</li>
    <li>Finalement on affiche touts les carrés où ils doivent être grâce à leur position dans le tableau que l'on convertit en position en pixels.</li>
</ul>

</div>
    </span>
    
    
    <aside id="side">
            <div id="Sommaire" class="Sommaire">
                <div>
                    <h2>Sommaire</h2>
                </div>
                <ul>
                    <li><a href="#classe_tablo">tablo</a></li>
                        <ul>
                            <li><a href="#fctn_tablo_test">tablo.test()</a></li>
                            <li><a href="#fctn_tablo_update">tablo.update()</a></li>
                        </ul>
                    <li><a href="#classe_newBlock">newBlock</a></li>
                        <ul>
                            <li><a href="#fctn_newBlock_init">newBlock.__init__()</a></li>
                            <li><a href="#fctn_newBlock_deplacement">newBlock.deplacement()</a></li>
                            <li><a href="#fctn_newBlock_rotation">newBlock.rotation()</a></li>
                        </ul>
                    <li><a href="#autres_fonctions">Autres fonctions</a></li>
                        <ul>
                            <li><a href="#give_position">give_position()</a></li>
                            <li><a href="#give_couleur">give_couleur()</a></li>
                            <li><a href="#test_rotation_coromp">test_rotation_coromp()</a></li>
                        </ul>
                </ul>
            </div>   
    </aside>
    
    
    </body>
</html>
